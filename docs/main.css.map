{
  "version": 3,
  "file": "main.css",
  "sources": [
    "../App.svelte",
    "../GLApp.svelte",
    "../TestApp.svelte",
    "../Keypad.svelte",
    "../Scene.svelte",
    "../Layer.svelte",
    "../Overlay.svelte"
  ],
  "sourcesContent": [
    "<script>\n\timport { onMount } from 'svelte';\n\n\texport let greeting;\n\n\tlet pin;\n\tlet view;\n\t$: view = pin ? pin.replace(/\\d(?!$)/g, '*') : 'enter your pin';\n\n\tfunction handleSubmit() {\n\t\talert(`submitted ${pin}`);\n\t}\n\n\tlet canvas;\n\n\tonMount(() => {\n\t\tconst ctx = canvas.getContext(\"2d\");\n\t\tctx.fillStyle = \"#00f\";\n\t\tctx.fillRect(0, 0, canvas.width, canvas.height);\n\t\tctx.fillStyle = \"#fff\";\n\t\tctx.font = \"20px Arial\";\n\t\tctx.fillText(\"2d Canvas works, too\", 10, 100);\n\n\t\tlet frame;\n\n\t\t(function loop() {\n\t\t\tframe = requestAnimationFrame(loop);\n\n\t\t\tconst imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\n\t\t\tfor (let p = 0; p < imageData.data.length; p += 4) {\n\t\t\t\tconst i = p / 4;\n\t\t\t\tconst x = i % canvas.width;\n\t\t\t\tconst y = i / canvas.height >>> 0;\n\n\t\t\t\tconst t = window.performance.now();\n\n\t\t\t\tconst r = 64 + (128 * x / canvas.width) + (64 * Math.sin(t / 1000));\n\t\t\t\tconst g = 64 + (128 * y / canvas.height) + (64 * Math.cos(t / 1000));\n\t\t\t\tconst b = 128;\n\n\t\t\t\timageData.data[p + 0] = r;\n\t\t\t\timageData.data[p + 1] = g;\n\t\t\t\timageData.data[p + 2] = b;\n\t\t\t\timageData.data[p + 3] = 255;\n\t\t\t}\n\n\t\t\tctx.putImageData(imageData, 0, 0);\n\t\t}());\n\n\t\treturn () => {\n\t\t\tcancelAnimationFrame(frame);\n\t\t};\n\t});\n</script>\n\n<style>\n\tcanvas {\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tbackground-color: #666;\n\t\t-webkit-mask: url(\"/sveltr/images/svelte-logo-mask.svg\") 50% 50% content-box view-box no-repeat;\n\t\tmask: url(\"/sveltr/images/svelte-logo-mask.svg\") 50% 50% content-box view-box no-repeat;\n\t}\n\t#view {\n\t\ttext-align: center;\n\t}\n</style>\n\n<div id=\"view\">\n\t<h3>{@html greeting}</h3>\n\t<canvas\n\t\t\tbind:this={canvas}\n\t\t\twidth={32}\n\t\t\theight={32}\n\t></canvas>\n</div>\n",
    "<script>\n    import { onMount } from 'svelte';\n    import * as GL from '@sveltejs/gl';\n\n    export let title;\n\n    export let color = '#ff3e00';\n\n    function adjustColor (clr, height = 1) {\n        const r = parseInt('0x' + clr.substr(1, 2), 16),\n                g = parseInt('0x' + clr.substr(3, 2), 16),\n                b = parseInt('0x' + clr.substr(5, 2), 16);\n\n        const hr = Math.floor(r * (height / 0.25)),\n                hb = Math.floor(b * (height / 0.25));\n        return Math.abs((((hr < 255) ? hr : r) << 16) + (g << 8) + ((hb < 255) ? hb : b));\n    }\n\n    const data = JSON.parse(document.getElementById('gl_data_in_html').children[0].innerHTML);\n    const heightmap = [];\n    const gridSizeX = 10;\n    const gridSizeZ = 10;\n\n    for (let z=0; z < data.length; z++) {\n        const xx = [];\n        for (const x of Object.getOwnPropertyNames(data[z])) {\n            xx.push(data[z][x])\n        }\n        heightmap[z] = xx;\n    }\n\n    console.log(heightmap);\n\n    let w = 1;\n    let h = 1;\n    let d = 1;\n\n    const light = {};\n\n    onMount(() => {\n        let frame;\n\n        const loop = () => {\n            frame = requestAnimationFrame(loop);\n\n            light.x = 3 * Math.sin(Date.now() * 0.001);\n            light.y = 2.5 + 2 * Math.sin(Date.now() * 0.0004);\n            light.z = 3 * Math.cos(Date.now() * 0.002);\n        };\n\n        loop();\n\n        return () => cancelAnimationFrame(frame);\n    });\n</script>\n\n<style>\n    .controls {\n        float: right;\n        position: relative;\n        margin: 8px;\n        margin-top: -160px;\n        width: 300px;\n        height: 128px;\n        padding: 1em;\n        background-color: rgba(255,255,255,0.7);\n        border-radius: 2px;\n        z-index: 2;\n    }\n\n    @media screen and (max-width: 480px) {\n        .controls {\n            margin-top: 8px;\n        }\n    }\n\n    .keys {\n        position: absolute;\n        width: 256px;\n        height: 256px;\n        top: calc(50vh - (100vw / 5.75));\n        padding: 24px;\n        background-color: transparent;\n    }\n\n    .keys * {\n        padding: 24px;\n    }\n</style>\n\n<GL.Scene>\n    <GL.Target id=\"center\" location={[0, h/2, 0]}/>\n\n    <GL.OrbitControls maxPolarAngle={Math.PI / 2} let:location>\n        <GL.PerspectiveCamera {location} lookAt=\"center\" near={0.01} far={1000}/>\n    </GL.OrbitControls>\n\n    <GL.AmbientLight intensity={0.3}/>\n    <GL.DirectionalLight direction={[-1,-1,-1]} intensity={0.5}/>\n\n    {#each Array(heightmap.length) as _, k}\n        {#each Array(heightmap[k].length) as _, i}\n        <!-- box -->\n            <GL.Mesh geometry={GL.box({ x: 0, y: 0, z: 0 , w: (gridSizeX / heightmap[i].length), h: (1 * heightmap[k][i]), d: (gridSizeZ / heightmap.length) })}\n                     location={[ (-(gridSizeX / 2) + (i * (gridSizeX / heightmap[0].length))), 0, (-(gridSizeZ / 2) + (k * (gridSizeZ / heightmap.length))) ]}\n                     rotation={[ 0, 0, 0]}\n                     scale={[ w, h, d]}\n                     uniforms={{ color: adjustColor(color, heightmap[k][i]) }}\n            />\n        {/each}\n    {/each}\n\n        <!-- spheres -->\n    <GL.Mesh\n            geometry={GL.sphere({ turns: 36, bands: 36 })}\n            location={[ -0.5, 2.4, 1.2 ]}\n            scale={0.4}\n            uniforms={{ color: 0x123456, alpha: 0.9 }}\n            transparent\n    />\n\n    <GL.Mesh\n            geometry={GL.sphere({ turns: 36, bands: 36 })}\n            location={[ -1.4, 2.6, 0.2 ]}\n            scale={0.6}\n            uniforms={{ color: 0x336644, alpha: 1.0 }}\n            transparent\n    />\n\n    <!-- floor -->\n    <GL.Mesh\n            geometry={GL.plane()}\n            location={[0,-0.01,0]}\n            rotation={[-90,0,0]}\n            scale={10}\n            uniforms={{ color: 0xffffff }}\n    />\n\n    <!-- ceiling -->\n    <GL.Mesh\n            geometry={GL.plane()}\n            location={[0,5.0,0]}\n            rotation={[90,0,0]}\n            scale={10}\n            uniforms={{ color: 0xffffff }}\n    />\n\n    <!-- wall1 -->\n    <GL.Mesh\n            geometry={GL.plane()}\n            location={[0,-0.01,-10.0]}\n            rotation={[0,0,0]}\n            scale={10}\n            uniforms={{ color: 0xffffff }}\n    />\n\n    <!-- wall2 -->\n    <GL.Mesh\n            geometry={GL.plane()}\n            location={[10.0,-0.01,0.0]}\n            rotation={[0,-90,0]}\n            scale={10}\n            uniforms={{ color: 0xffffff }}\n    />\n\n    <!-- wall3 -->\n    <GL.Mesh\n            geometry={GL.plane()}\n            location={[-10.0,-0.01,0.0]}\n            rotation={[0,90,0]}\n            scale={10}\n            uniforms={{ color: 0xffffff }}\n    />\n\n    <!-- moving light -->\n    <GL.Group location={[light.x,light.y,light.z]}>\n        <GL.Mesh\n                geometry={GL.sphere({ turns: 36, bands: 36 })}\n                location={[0,0.2,0]}\n                scale={0.1}\n                uniforms={{ color: 0xffffff, emissive: 0xff0000 }}\n        />\n\n        <GL.PointLight\n                location={[0,0,0]}\n                color={0xff0000}\n                intensity={0.6}\n        />\n    </GL.Group>\n</GL.Scene>\n\n<div class=\"controls\">\n    <label>\n        <input type=\"color\" style=\"height: 40px\" bind:value={color}>\n    </label>\n\n    <label>\n        <input type=\"range\" bind:value={w} min={0.1} max={5} step={0.1}> width ({w})\n    </label>\n\n    <label>\n        <input type=\"range\" bind:value={h} min={0.1} max={5} step={0.1}> height ({h})\n    </label>\n\n    <label>\n        <input type=\"range\" bind:value={d} min={0.1} max={5} step={0.1}> depth ({d})\n    </label>\n</div>\n",
    "<script>\n\timport { onMount } from 'svelte';\n\timport Keypad from './components/Keypad.svelte';\n\n\texport let title;\n\n\tlet pin;\n\tlet view;\n\t$: view = pin ? pin.replace(/\\d(?!$)/g, '*') : 'enter your pin';\n\n\tfunction handleSubmit() {\n\t\talert(`submitted ${pin}`);\n\t}\n\n\timport * as GL from '@sveltejs/gl';\n\n\texport let color = '#ff3e00';\n\tlet w = 1;\n\tlet h = 1;\n\tlet d = 1;\n\n\tconst from_hex = hex => parseInt(hex.slice(1), 16);\n\n\tconst light = {};\n\n\tonMount(() => {\n\t\tlet frame;\n\n\t\tconst loop = () => {\n\t\t\tframe = requestAnimationFrame(loop);\n\n\t\t\tlight.x = 3 * Math.sin(Date.now() * 0.001);\n\t\t\tlight.y = 2.5 + 2 * Math.sin(Date.now() * 0.0004);\n\t\t\tlight.z = 3 * Math.cos(Date.now() * 0.002);\n\t\t};\n\n\t\tloop();\n\n\t\treturn () => cancelAnimationFrame(frame);\n\t});\n</script>\n\n<style>\n\t.controls {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tmargin: 8px;\n\t\tmargin-left: 200px;\n\t\twidth: 300px;\n\t\theight: 128px;\n\t\tpadding: 1em;\n\t\tbackground-color: rgba(255,255,255,0.7);\n\t\tborder-radius: 2px;\n\t\tz-index: 2;\n\t}\n\n\t.keys {\n\t\tposition: absolute;\n\t\twidth: 256px;\n\t\theight: 256px;\n\t\ttop: calc(50vh - (100vw / 5.75));\n\t\tpadding: 24px;\n\t\tbackground-color: transparent;\n\t}\n\n\t.keys * {\n\t\tpadding: 24px;\n\t}\n</style>\n\n<GL.Scene>\n\t<GL.Target id=\"center\" location={[0, h/2, 0]}/>\n\n\t<GL.OrbitControls maxPolarAngle={Math.PI / 2} let:location>\n\t\t<GL.PerspectiveCamera {location} lookAt=\"center\" near={0.01} far={1000}/>\n\t</GL.OrbitControls>\n\n\t<GL.AmbientLight intensity={0.3}/>\n\t<GL.DirectionalLight direction={[-1,-1,-1]} intensity={0.5}/>\n\n\t<!-- box -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.box({})}\n\t\t\tlocation={[0,h/2,0]}\n\t\t\trotation={[0,-20,0]}\n\t\t\tscale={[w,h,d]}\n\t\t\tuniforms={{ color: from_hex(color) }}\n\t/>\n\n\t<!-- spheres -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.sphere({ turns: 36, bands: 36 })}\n\t\t\tlocation={[-0.5, 0.4, 1.2]}\n\t\t\tscale={0.4}\n\t\t\tuniforms={{ color: 0x123456, alpha: 0.9 }}\n\t\t\ttransparent\n\t/>\n\n\t<GL.Mesh\n\t\t\tgeometry={GL.sphere({ turns: 36, bands: 36 })}\n\t\t\tlocation={[-1.4, 0.6, 0.2]}\n\t\t\tscale={0.6}\n\t\t\tuniforms={{ color: 0x336644, alpha: 1.0 }}\n\t\t\ttransparent\n\t/>\n\n\t<!-- floor -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[0,-0.01,0]}\n\t\t\trotation={[-90,0,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- ceiling -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[0,5.0,0]}\n\t\t\trotation={[90,0,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- wall1 -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[0,-0.01,-10.0]}\n\t\t\trotation={[0,0,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- wall2 -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[10.0,-0.01,0.0]}\n\t\t\trotation={[0,-90,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- wall3 -->\n\t<GL.Mesh\n\t\t\tgeometry={GL.plane()}\n\t\t\tlocation={[-10.0,-0.01,0.0]}\n\t\t\trotation={[0,90,0]}\n\t\t\tscale={10}\n\t\t\tuniforms={{ color: 0xffffff }}\n\t/>\n\n\t<!-- moving light -->\n\t<GL.Group location={[light.x,light.y,light.z]}>\n\t\t<GL.Mesh\n\t\t\t\tgeometry={GL.sphere({ turns: 36, bands: 36 })}\n\t\t\t\tlocation={[0,0.2,0]}\n\t\t\t\tscale={0.1}\n\t\t\t\tuniforms={{ color: 0xffffff, emissive: 0xff0000 }}\n\t\t/>\n\n\t\t<GL.PointLight\n\t\t\t\tlocation={[0,0,0]}\n\t\t\t\tcolor={0xff0000}\n\t\t\t\tintensity={0.6}\n\t\t/>\n\t</GL.Group>\n</GL.Scene>\n\n<div class=\"controls\">\n\t<label>\n\t\t<input type=\"color\" style=\"height: 40px\" bind:value={color}>\n\t</label>\n\n\t<label>\n\t\t<input type=\"range\" bind:value={w} min={0.1} max={5} step={0.1}> width ({w})\n\t</label>\n\n\t<label>\n\t\t<input type=\"range\" bind:value={h} min={0.1} max={5} step={0.1}> height ({h})\n\t</label>\n\n\t<label>\n\t\t<input type=\"range\" bind:value={d} min={0.1} max={5} step={0.1}> depth ({d})\n\t</label>\n</div>\n\n<div class=\"controls keys\">\n\t<h1 style=\"color: {pin ? '#999' : '#fff'}\">{view}</h1>\n\t<Keypad bind:value={pin} on:submit={handleSubmit}/>\n</div>\n",
    "<script>\n\timport { createEventDispatcher } from 'svelte';\n\n\texport let value = '';\n\n\tconst dispatch = createEventDispatcher();\n\n\tconst select = num => () => value += num;\n\tconst clear  = () => value = '';\n\tconst submit = () => dispatch('submit');\n</script>\n\n<style>\n\t.keypad {\n\t\tdisplay: grid;\n\t\tgrid-template-columns: repeat(3, 5em);\n\t\tgrid-template-rows: repeat(4, 3em);\n\t\tgrid-gap: 0.5em\n\t}\n\n\tbutton {\n\t\tmargin: 0\n\t}\n</style>\n\n<div class=\"keypad\">\n\t<button on:click={select(1)}>1</button>\n\t<button on:click={select(2)}>2</button>\n\t<button on:click={select(3)}>3</button>\n\t<button on:click={select(4)}>4</button>\n\t<button on:click={select(5)}>5</button>\n\t<button on:click={select(6)}>6</button>\n\t<button on:click={select(7)}>7</button>\n\t<button on:click={select(8)}>8</button>\n\t<button on:click={select(9)}>9</button>\n\n\t<button disabled={!value} on:click={clear}>clear</button>\n\t<button on:click={select(0)}>0</button>\n\t<button disabled={!value} on:click={submit}>submit</button>\n</div>",
    "<script context=\"module\">\n\timport { readable } from 'svelte/store';\n\n\tfunction is_intersecting(el) {\n\t\t// TODO this shouldn't be necessary. But the initial value\n\t\t// of entry.isIntersecting in an IO can be incorrect, it\n\t\t// turns out? need to investigate further\n\t\tconst bcr = el.getBoundingClientRect();\n\n\t\treturn (\n\t\t\tbcr.bottom > 0 &&\n\t\t\tbcr.right  > 0 &&\n\t\t\tbcr.top    < window.innerHeight &&\n\t\t\tbcr.left   < window.innerWidth\n\t\t);\n\t}\n\n\tfunction get_visibility(node) {\n\t\treturn readable(false, set => {\n\t\t\tif (typeof IntersectionObserver !== 'undefined') {\n\t\t\t\tconst observer = new IntersectionObserver(entries => {\n\t\t\t\t\t// set(entries[0].isIntersecting);\n\t\t\t\t\tset(is_intersecting(node));\n\t\t\t\t});\n\n\t\t\t\tobserver.observe(node);\n\t\t\t\treturn () => observer.unobserve(node);\n\t\t\t}\n\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tfunction handler() {\n\t\t\t\t\tconst { top, bottom } = node.getBoundingClientRect();\n\t\t\t\t\tset(bottom > 0 && top < window.innerHeight);\n\t\t\t\t}\n\n\t\t\t\twindow.addEventListener('scroll', handler);\n\t\t\t\twindow.addEventListener('resize', handler);\n\n\t\t\t\treturn () => {\n\t\t\t\t\twindow.removeEventListener('scroll', handler);\n\t\t\t\t\twindow.removeEventListener('resize', handler);\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t}\n</script>\n\n<script>\n\timport { setContext, onMount, onDestroy, tick } from 'svelte';\n\timport { writable } from 'svelte/store';\n\timport { RENDERER, LAYER, PARENT, CAMERA, create_layer } from '../internal/index.mjs';\n\timport { create_worker, process_color } from '../internal/utils.mjs';\n\timport * as mat4 from 'gl-matrix/mat4';\n\timport * as vec3 from 'gl-matrix/vec3';\n\n\texport let background = [1, 1, 1];\n\texport let backgroundOpacity = 1;\n\texport let fog = undefined;\n\texport let pixelRatio = undefined;\n\n\tconst use_fog = 'fog' in $$props;\n\n\t$: bg = process_color(background);\n\n\tlet canvas;\n\tlet visible = writable(false);\n\tlet pending = false;\n\tlet update_scheduled = false;\n\tlet w;\n\tlet h;\n\n\tlet gl;\n\tlet draw = () => {};\n\tlet camera_stores = {\n\t\tcamera_matrix: writable(),\n\t\tview: writable(),\n\t\tprojection: writable()\n\t};\n\n\tconst invalidate = typeof window !== 'undefined'\n\t\t? () => {\n\t\t\tif (!update_scheduled) {\n\t\t\t\tupdate_scheduled = true;\n\t\t\t\trequestAnimationFrame(draw);\n\t\t\t}\n\t\t}\n\t\t: () => {};\n\n\tconst width = writable(1);\n\tconst height = writable(1);\n\n\tconst root_layer = create_layer(0, invalidate);\n\n\tconst default_camera = { /* TODO */ };\n\tlet camera = default_camera;\n\tconst num_lights = 8;\n\n\tconst meshes = [];\n\n\t// lights\n\tconst lights = {\n\t\tambient: [],\n\t\tdirectional: [],\n\t\tpoint: []\n\t};\n\n\tfunction add_to(array) {\n\t\treturn fn => {\n\t\t\tarray.push(fn);\n\t\t\tinvalidate();\n\n\t\t\tonDestroy(() => {\n\t\t\t\tconst i = array.indexOf(fn);\n\t\t\t\tif (~i) array.splice(i, 1);\n\t\t\t\tinvalidate();\n\t\t\t});\n\t\t}\n\t}\n\n\tconst targets = new Map();\n\tlet camera_position_changed_since_last_render = true;\n\n\tconst scene = {\n\t\tdefines: [\n\t\t\t`#define NUM_LIGHTS 2\\n` + // TODO configure this\n\t\t\t`#define USE_FOG ${use_fog}\\n`\n\t\t].join(''),\n\n\t\tadd_camera: _camera => {\n\t\t\tif (camera && camera !== default_camera) {\n\t\t\t\tthrow new Error(`A scene can only have one camera`);\n\t\t\t}\n\n\t\t\tcamera = _camera;\n\t\t\tinvalidate();\n\n\t\t\t// TODO this is garbage\n\t\t\tcamera_stores.camera_matrix.set(camera.matrix);\n\t\t\tcamera_stores.projection.set(camera.projection);\n\t\t\tcamera_stores.view.set(camera.view);\n\n\t\t\tonDestroy(() => {\n\t\t\t\tcamera = default_camera;\n\t\t\t\tinvalidate();\n\t\t\t});\n\t\t},\n\n\t\tupdate_camera: camera => {\n\t\t\t// for overlays\n\t\t\tcamera_stores.camera_matrix.set(camera.matrix);\n\t\t\tcamera_stores.view.set(camera.view);\n\t\t\tcamera_stores.projection.set(camera.projection);\n\n\t\t\tcamera_position_changed_since_last_render = true;\n\t\t\tinvalidate();\n\t\t},\n\n\t\tadd_directional_light: add_to(lights.directional),\n\t\tadd_point_light: add_to(lights.point),\n\t\tadd_ambient_light: add_to(lights.ambient),\n\n\t\tget_target(id) {\n\t\t\tif (!targets.has(id)) targets.set(id, writable(null))\n\t\t\treturn targets.get(id);\n\t\t},\n\n\t\tinvalidate,\n\n\t\t...camera_stores,\n\n\t\twidth,\n\t\theight\n\t};\n\n\tsetContext(RENDERER, scene);\n\tsetContext(LAYER, root_layer);\n\n\tconst origin = mat4.identity(mat4.create());\n\tconst ctm = writable(origin);\n\tsetContext(PARENT, {\n\t\tget_matrix_world: () => origin,\n\t\tctm: { subscribe: ctm.subscribe }\n\t});\n\n\tonMount(() => {\n\t\tscene.canvas = canvas;\n\t\tgl = scene.gl = canvas.getContext('webgl');\n\t\tvisible = get_visibility(canvas);\n\n\t\tconst extensions = [\n\t\t\t'OES_element_index_uint',\n\t\t\t'OES_standard_derivatives'\n\t\t];\n\n\t\textensions.forEach(name => {\n\t\t\tconst ext = gl.getExtension(name);\n\t\t\tif (!ext) {\n\t\t\t\tthrow new Error(`Unsupported extension: ${name}`);\n\t\t\t}\n\t\t});\n\n\t\tdraw = force => {\n\t\t\tif (!camera) return; // TODO make this `!ready` or something instead\n\n\t\t\tif (dimensions_need_update) {\n\t\t\t\tconst DPR = pixelRatio || window.devicePixelRatio || 1;\n\t\t\t\tcanvas.width = $width * DPR;\n\t\t\t\tcanvas.height = $height * DPR;\n\t\t\t\tgl.viewport(0, 0, $width * DPR, $height * DPR);\n\n\t\t\t\tdimensions_need_update = false;\n\t\t\t}\n\n\t\t\tupdate_scheduled = false;\n\n\t\t\tif (!$visible && !force) {\n\t\t\t\tpending = true;\n\t\t\t\treturn;\n\t\t\t};\n\n\t\t\tpending = false;\n\n\t\t\tgl.clearColor(...bg, backgroundOpacity);\n\t\t\tgl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n\t\t\tgl.enable(gl.CULL_FACE);\n\t\t\tgl.enable(gl.BLEND);\n\n\t\t\t// calculate total ambient light\n\t\t\tconst ambient_light = lights.ambient.reduce((total, { color, intensity }) => {\n\t\t\t\treturn [\n\t\t\t\t\tMath.min(total[0] + color[0] * intensity, 1),\n\t\t\t\t\tMath.min(total[1] + color[1] * intensity, 1),\n\t\t\t\t\tMath.min(total[2] + color[2] * intensity, 1)\n\t\t\t\t];\n\t\t\t}, new Float32Array([0, 0, 0]));\n\n\t\t\tlet previous_program;\n\n\t\t\tlet previous_state = {\n\t\t\t\t[gl.DEPTH_TEST]: null,\n\t\t\t\t[gl.CULL_FACE]: null\n\t\t\t};\n\n\t\t\tconst enable = (key, enabled) => {\n\t\t\t\tif (previous_state[key] !== enabled) {\n\t\t\t\t\tif (enabled) gl.enable(key);\n\t\t\t\t\telse gl.disable(key);\n\n\t\t\t\t\tprevious_state[key] = enabled;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfunction render_mesh({\n\t\t\t\tmodel,\n\t\t\t\tmodel_inverse_transpose,\n\t\t\t\tgeometry,\n\t\t\t\tmaterial,\n\t\t\t\tdepthTest,\n\t\t\t\tdoubleSided\n\t\t\t}) {\n\t\t\t\t// TODO should this even be possible?\n\t\t\t\tif (!material) return;\n\n\t\t\t\tenable(gl.DEPTH_TEST, depthTest !== false);\n\t\t\t\tenable(gl.CULL_FACE, doubleSided !== true);\n\n\t\t\t\tgl.blendFuncSeparate(\n\t\t\t\t\tgl.SRC_ALPHA, // source rgb\n\t\t\t\t\tgl.ONE_MINUS_SRC_ALPHA, // dest rgb\n\t\t\t\t\tgl.SRC_ALPHA, // source alpha\n\t\t\t\t\tgl.ONE // dest alpha\n\t\t\t\t);\n\n\t\t\t\tif (material.program !== previous_program) {\n\t\t\t\t\tprevious_program = material.program;\n\n\t\t\t\t\t// TODO move logic to the mesh/material?\n\t\t\t\t\tgl.useProgram(material.program);\n\n\t\t\t\t\t// set built-ins\n\t\t\t\t\tgl.uniform3fv(material.uniform_locations.AMBIENT_LIGHT, ambient_light);\n\n\t\t\t\t\tif (use_fog) {\n\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.FOG_COLOR, bg);\n\t\t\t\t\t\tgl.uniform1f(material.uniform_locations.FOG_DENSITY, fog);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (material.uniform_locations.DIRECTIONAL_LIGHTS) {\n\t\t\t\t\t\tfor (let i = 0; i < num_lights; i += 1) {\n\t\t\t\t\t\t\tconst light = lights.directional[i];\n\t\t\t\t\t\t\tif (!light) break;\n\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.DIRECTIONAL_LIGHTS[i].direction, light.direction);\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.DIRECTIONAL_LIGHTS[i].color, light.color);\n\t\t\t\t\t\t\tgl.uniform1f(material.uniform_locations.DIRECTIONAL_LIGHTS[i].intensity, light.intensity);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (material.uniform_locations.POINT_LIGHTS) {\n\t\t\t\t\t\tfor (let i = 0; i < num_lights; i += 1) {\n\t\t\t\t\t\t\tconst light = lights.point[i];\n\t\t\t\t\t\t\tif (!light) break;\n\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.POINT_LIGHTS[i].location, light.location);\n\t\t\t\t\t\t\tgl.uniform3fv(material.uniform_locations.POINT_LIGHTS[i].color, light.color);\n\t\t\t\t\t\t\tgl.uniform1f(material.uniform_locations.POINT_LIGHTS[i].intensity, light.intensity);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tgl.uniform3fv(material.uniform_locations.CAMERA_WORLD_POSITION, camera.world_position);\n\t\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.VIEW, false, camera.view);\n\t\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.PROJECTION, false, camera.projection);\n\t\t\t\t}\n\n\t\t\t\t// set mesh-specific built-in uniforms\n\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.MODEL, false, model);\n\t\t\t\tgl.uniformMatrix4fv(material.uniform_locations.MODEL_INVERSE_TRANSPOSE, false, model_inverse_transpose);\n\n\t\t\t\t// set material-specific built-in uniforms\n\t\t\t\tmaterial.apply_uniforms(gl);\n\n\t\t\t\t// set attributes\n\t\t\t\tgeometry.set_attributes(gl);\n\n\t\t\t\t// draw\n\t\t\t\tif (geometry.index) {\n\t\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, geometry.buffers.__index);\n\t\t\t\t\tgl.drawElements(gl[geometry.primitive], geometry.index.length, gl.UNSIGNED_INT, 0);\n\t\t\t\t} else {\n\t\t\t\t\tconst primitiveType = gl[geometry.primitive];\n\t\t\t\t\tgl.drawArrays(primitiveType, 0, geometry.count);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction render_layer(layer) {\n\t\t\t\tif (layer.needs_sort) {\n\t\t\t\t\tlayer.child_layers.sort((a, b) => a.index - b.index);\n\t\t\t\t\tlayer.needs_sort = false;\n\t\t\t\t}\n\n\t\t\t\tgl.depthMask(true);\n\t\t\t\tgl.clearDepth(1.0);\n\t\t\t\tgl.clear(gl.DEPTH_BUFFER_BIT);\n\n\t\t\t\tfor (let i = 0; i < layer.meshes.length; i += 1) {\n\t\t\t\t\trender_mesh(layer.meshes[i]);\n\t\t\t\t}\n\n\t\t\t\t// TODO sort transparent meshes, furthest to closest\n\t\t\t\tgl.depthMask(false);\n\n\t\t\t\tif (camera_position_changed_since_last_render || layer.needs_transparency_sort) {\n\t\t\t\t\tsort_transparent_meshes(layer.transparent_meshes);\n\t\t\t\t\tlayer.needs_transparency_sort = false;\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < layer.transparent_meshes.length; i += 1) {\n\t\t\t\t\trender_mesh(layer.transparent_meshes[i]);\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < layer.child_layers.length; i += 1) {\n\t\t\t\t\trender_layer(layer.child_layers[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trender_layer(root_layer);\n\t\t\tcamera_position_changed_since_last_render = false;\n\t\t};\n\n\t\t// for some wacky reason, Adblock Plus seems to prevent the\n\t\t// initial dimensions from being correctly reported\n\t\tconst timeout = setTimeout(() => {\n\t\t\t$width = canvas.clientWidth;\n\t\t\t$height = canvas.clientHeight;\n\t\t});\n\n\t\ttick().then(() => draw(true));\n\n\t\treturn () => {\n\t\t\tgl.getExtension('WEBGL_lose_context').loseContext();\n\t\t\tclearTimeout(timeout);\n\t\t};\n\t});\n\n\tconst sort_transparent_meshes = meshes => {\n\t\tif (meshes.length < 2) return;\n\n\t\tconst lookup = new Map();\n\t\tconst out = new Float32Array(16);\n\n\t\tmeshes.forEach(mesh => {\n\t\t\tconst z = mat4.multiply(out, camera.view, mesh.model)[14];\n\t\t\tlookup.set(mesh, z);\n\t\t});\n\n\t\tmeshes.sort((a, b) => lookup.get(a) - lookup.get(b));\n\t};\n\n\tlet dimensions_need_update = true;\n\n\tconst update_dimensions = () => {\n\t\tdimensions_need_update = true;\n\t\tinvalidate();\n\t};\n\n\t$: ($width, $height, update_dimensions());\n\t$: (background, backgroundOpacity, fog, scene.invalidate());\n\t$: if ($visible && pending) scene.invalidate();\n</script>\n\n<style>\n\t.container, canvas {\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\theight: 100%;\n\t\tdisplay: block;\n\t\toverflow: hidden;\n\t}\n</style>\n\n<div class=\"container\" bind:clientWidth={$width} bind:clientHeight={$height}>\n\t<canvas bind:this={canvas}></canvas>\n\n\t{#if gl}\n\t\t<slot width={$width} height={$height}></slot>\n\t{/if}\n</div>",
    "<script>\n\timport { get_layer, set_layer } from '../internal/index.mjs';\n\n\texport let index = undefined;\n\n\tset_layer(get_layer().add_child(index));\n</script>\n\n<div class=\"layer\">\n\t<slot></slot>\n</div>\n\n<style>\n\t/* for overlays, create a stacking context */\n\t.layer {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n</style>",
    "<script>\n\timport Point from './Point.svelte';\n\n\texport let location;\n\texport let direction = undefined;\n\texport let snap = false;\n\n\t$: px = n => `${snap ? Math.round(n) : n}px`;\n</script>\n\n<Point {location} {direction} let:x let:y let:vector>\n\t<span\n\t\tclass=\"overlay\"\n\t\tstyle=\"transform: translate3d({px(x)}, {px(y)}, 0)\"\n\t>\n\t\t<slot vector={vector}></slot>\n\t</span>\n</Point>\n\n<style>\n\t.overlay {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\ttop: 0;\n\t\tuser-select: none;\n\t\t-moz-user-select: none;\n\t\twill-change: transform;\n\t}\n</style>"
  ],
  "names": [],
  "mappings": "AAyDC,MAAM,eAAC,CAAC,AACP,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,gBAAgB,CAAE,IAAI,CACtB,YAAY,CAAE,IAAI,gCAAgC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,CAAC,QAAQ,CAAC,SAAS,CAC1F,IAAI,CAAE,IAAI,gCAAgC,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,CAAC,QAAQ,CAAC,SAAS,AACnF,CAAC,AACD,KAAK,eAAC,CAAC,AACN,UAAU,CAAE,MAAM,AACnB,CAAC;ACTE,SAAS,cAAC,CAAC,AACP,KAAK,CAAE,KAAK,CACZ,QAAQ,CAAE,QAAQ,CAClB,MAAM,CAAE,GAAG,CACX,UAAU,CAAE,MAAM,CAClB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,GAAG,CACZ,gBAAgB,CAAE,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CACvC,aAAa,CAAE,GAAG,CAClB,OAAO,CAAE,CAAC,AACd,CAAC,AAED,OAAO,MAAM,CAAC,GAAG,CAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AAClC,SAAS,cAAC,CAAC,AACP,UAAU,CAAE,GAAG,AACnB,CAAC,AACL,CAAC;AC/BJ,SAAS,8BAAC,CAAC,AACV,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,MAAM,CAAE,GAAG,CACX,WAAW,CAAE,KAAK,CAClB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,OAAO,CAAE,GAAG,CACZ,gBAAgB,CAAE,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CACvC,aAAa,CAAE,GAAG,CAClB,OAAO,CAAE,CAAC,AACX,CAAC,AAED,KAAK,8BAAC,CAAC,AACN,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,KAAK,CACZ,MAAM,CAAE,KAAK,CACb,GAAG,CAAE,KAAK,IAAI,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAChC,OAAO,CAAE,IAAI,CACb,gBAAgB,CAAE,WAAW,AAC9B,CAAC,AAED,oBAAK,CAAC,eAAE,CAAC,AACR,OAAO,CAAE,IAAI,AACd,CAAC;ACtDD,OAAO,cAAC,CAAC,AACR,OAAO,CAAE,IAAI,CACb,qBAAqB,CAAE,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CACrC,kBAAkB,CAAE,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAClC,QAAQ,CAAE,KAAK;CAChB,CAAC,AAED,MAAM,cAAC,CAAC,AACP,MAAM,CAAE,CAAC;CACV,CAAC;ACsYD,wBAAU,CAAE,MAAM,cAAC,CAAC,AACnB,QAAQ,CAAE,QAAQ,CAClB,KAAK,CAAE,IAAI,CACX,MAAM,CAAE,IAAI,CACZ,OAAO,CAAE,KAAK,CACd,QAAQ,CAAE,MAAM,AACjB,CAAC;ACpZD,MAAM,cAAC,CAAC,AACP,QAAQ,CAAE,QAAQ,CAClB,GAAG,CAAE,CAAC,CACN,IAAI,CAAE,CAAC,AACR,CAAC;ACED,QAAQ,eAAC,CAAC,AACT,QAAQ,CAAE,QAAQ,CAClB,IAAI,CAAE,CAAC,CACP,GAAG,CAAE,CAAC,CACN,WAAW,CAAE,IAAI,CACjB,gBAAgB,CAAE,IAAI,CACtB,WAAW,CAAE,SAAS,AACvB,CAAC"
}
